Лабораторні роботи з дисципліни "Алгоритмів і структур даних"
Виконав: Гоцій Володимир Михайлович (Група ІР-25)

абораторна робота №1 (Варіант 2 Рівень 3)
'''Напишіть функцію, яка приймає невпорядкований масив цілих чисел і повертає діапазон індексів (початковий і кінцевий) найменшого підмасиву, який потрібно відсортувати для досягнення повного впорядкування всього масиву.

Наприклад, для вхідного масиву 1, 2, 4, 7, 10, 11, 7, 12, 6, 7, 16, 18, 19

Результат: (3, 9)

Підмасив, який потрібно відсортувати для впорядкування всього масиву, починається з індексу 3 (значення 7) і закінчується на індексі 9 (значення 7). У випадку, якщо вхідний масив відсортований, слд повернути кортеж (-1, -1)

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити сценарії коли: вхідний масив посортований, вхідний масив необхідно сортувати весь, масив містить лише 1 елемент.'''

Лабораторна робота №2 (Варіант 2 Рівень 3)
'''Пiсля швидкого випуску нової версiї своєї операцiйної системи, компанiя NanoSoft почала отримувати вiд користувачiв численнi повiдомлення про помилки. Щоб слiдкувати за прогресом виправлення помилок, команда розробникiв вирiшила поставити велику квадратну дошку, i прикрiпити до неї по листку для кожної помилки. Проте, щоб дошка вмiстилася в кiмнатi, потрiбно, щоб вона була не надто великою. Всi N листкiв мають прямокутну форму i однаковий розмiр W × H. Їх не можна повертати, а також накладати один на iнший. Знайдiть мiнiмальний розмiр квадратної дошки, яка здатна вмiстити всi листки. Приклад мiнiмальної дошки, яка може вмiстити 10 листкiв 2 × 3 (див картинку)

Вхiднi данi три числа N, W, H — кiлькiсть листкiв, ширина та висота листка вiдповiдно. • 1 ≤ N ≤ 1012 • 1 ≤ W ≤ 109 • 1 ≤ H ≤ 109

Вихiднi данi одне число — мiнiмальна довжина сторони квадратної дошки.

Приклад 1 N, W, H = 10, 2, 3 Результат: 9

Приклад 2 N, W, H = 2, 1000000000, 999999999 Результат: 1999999998

Приклад 3 N, W, H = 4, 1, 1 Результат: 2'''

Для заданого бінарного дерева перевірте, чи воно є збалансованим деревом. Бінарне дерево вважається збалансованим, якщо різниця у висоті його лівого та правого піддерев не перевищує 1 для будь-якого піддерева.

Розглянемо таке бінарне дерево:

    1
   / \
  2   3
 / \     
4   5   
Це дерево є збалансованим, оскільки різниця висоти лівого піддерева та правого піддерева не перевищує 1.

Реалізована вами функція is_tree_balanced(node: BinaryTree) -> bool отримує на вхід корінь бінарного дерева та повертає True, якщо бінарне дерево є збалансованим, та False, якщо воно не збалансоване.

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

class BinaryTree:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу BinaryTree наступним чином:

root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)

Варіант 1. заливка поля

Flood fill (також відомий як початкове заповнення) — це алгоритм, який визначає область, в яку входить певний вузол в багатовимірному масиві.

Він використовується в інструменті заповнення «ковша» програми малювання, щоб заповнити з’єднані, однаково забарвлені області іншим кольором, а також у таких іграх, як Go та Minesweeper.
Застосування для заповнення кольором певної обмеженої області також називається заливкою межі.

Алгоритм заливки приймає три параметри: початковий вузол, цільовий колір і колір заміни.

Розглянемо наступну матрицю (див. рисунок) 

Нехай ліворуч оригінальне значення кольоріів. Якщо початковий вузол (3, 9), цільовий колір — «ЧОРНИЙ», а колір заміни — «СІРИЙ», тоді алгоритм шукає всі вузли в матриці, які з’єднані з початковим вузлом таким самим кольором та змінює їх на колір заміни. Результат роботи алгоритму наведено праворуч



Формат даних у вхідному файлі input.txt
перший рядок: висота та ширина поля, яке містить кольорові елементи (розділені комою)
другий рядок: координати початкової точки, з якої слід починати зміну кольору
третій рядок: колір заміни

Приклад даних для рисунку зліва:
10,10
3,9
‘G’
      ['Y', 'Y', 'Y', 'G', 'G', 'G', 'G', 'G', 'G', 'G'],
            ['Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'G', 'X', 'X', 'X'],
            ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'X', 'X', 'X'],
            ['W', 'W', 'W', 'W', 'W', 'G', 'G', 'G', 'G', 'X'],
            ['W', 'R', 'R', 'R', 'R', 'R', 'G', 'X', 'X', 'X'],
            ['W', 'W', 'W', 'R', 'R', 'G', 'G', 'X', 'X', 'X'],
            ['W', 'B', 'W', 'R', 'R', 'R', 'R', 'R', 'R', 'X'],
            ['W', 'B', 'B', 'B', 'B', 'R', 'R', 'X', 'X', 'X'],
            ['W', 'B', 'B', 'X', 'B', 'B', 'B', 'B', 'X', 'X'],
            ['W', 'B', 'B', 'X', 'X', 'X', 'X', 'X', 'X', 'X']

Результат:
файл output.txt містить значення кольорів комірок поля після виконання заміни (для рисунку справа)

		[‘Y’, ‘Y’, ‘Y’, ‘G’, ‘G’, ‘G’, ‘G’, ‘G’, ‘G’, ‘G’]
[‘Y’, ‘Y’, ‘Y’, ‘Y’, ‘Y’, ‘Y’, ‘G’, ‘C’, ‘C’, ‘C’]
[‘G’, ‘G’, ‘G’, ‘G’, ‘G’, ‘G’, ‘G’, ‘C’, ‘C’, ‘C’]
[‘W’, ‘W’, ‘W’, ‘W’, ‘W’, ‘G’, ‘G’, ‘G’, ‘G’, ‘C’]
[‘W’, ‘R’, ‘R’, ‘R’, ‘R’, ‘R’, ‘G’, ‘C’, ‘C’, ‘C’]
[‘W’, ‘W’, ‘W’, ‘R’, ‘R’, ‘G’, ‘G’, ‘C’, ‘C’, ‘C’]
[‘W’, ‘B’, ‘W’, ‘R’, ‘R’, ‘R’, ‘R’, ‘R’, ‘R’, ‘C’]
[‘W’, ‘B’, ‘B’, ‘B’, ‘B’, ‘R’, ‘R’, ‘C’, ‘C’, ‘C’]
[‘W’, ‘B’, ‘B’, ‘C’, ‘B’, ‘B’, ‘B’, ‘B’, ‘C’, ‘C’]
[‘W’, ‘B’, ‘B’, ‘C’, ‘C’, ‘C’, ‘C’, ‘C’, ‘C’, ‘C’]


